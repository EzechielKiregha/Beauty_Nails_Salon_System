
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `DailyRegister` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model DailyRegister
 * 
 */
export type DailyRegisterModel = runtime.Types.Result.DefaultSelection<Prisma.$DailyRegisterPayload>

export type AggregateDailyRegister = {
  _count: DailyRegisterCountAggregateOutputType | null
  _avg: DailyRegisterAvgAggregateOutputType | null
  _sum: DailyRegisterSumAggregateOutputType | null
  _min: DailyRegisterMinAggregateOutputType | null
  _max: DailyRegisterMaxAggregateOutputType | null
}

export type DailyRegisterAvgAggregateOutputType = {
  openingCash: runtime.Decimal | null
  closingCash: runtime.Decimal | null
  expectedCash: runtime.Decimal | null
  discrepancy: runtime.Decimal | null
  totalSales: runtime.Decimal | null
  cashSales: runtime.Decimal | null
  cardSales: runtime.Decimal | null
  mobileSales: runtime.Decimal | null
}

export type DailyRegisterSumAggregateOutputType = {
  openingCash: runtime.Decimal | null
  closingCash: runtime.Decimal | null
  expectedCash: runtime.Decimal | null
  discrepancy: runtime.Decimal | null
  totalSales: runtime.Decimal | null
  cashSales: runtime.Decimal | null
  cardSales: runtime.Decimal | null
  mobileSales: runtime.Decimal | null
}

export type DailyRegisterMinAggregateOutputType = {
  id: string | null
  date: Date | null
  openingCash: runtime.Decimal | null
  closingCash: runtime.Decimal | null
  expectedCash: runtime.Decimal | null
  discrepancy: runtime.Decimal | null
  totalSales: runtime.Decimal | null
  cashSales: runtime.Decimal | null
  cardSales: runtime.Decimal | null
  mobileSales: runtime.Decimal | null
  notes: string | null
  closedBy: string | null
  closedAt: Date | null
  createdAt: Date | null
}

export type DailyRegisterMaxAggregateOutputType = {
  id: string | null
  date: Date | null
  openingCash: runtime.Decimal | null
  closingCash: runtime.Decimal | null
  expectedCash: runtime.Decimal | null
  discrepancy: runtime.Decimal | null
  totalSales: runtime.Decimal | null
  cashSales: runtime.Decimal | null
  cardSales: runtime.Decimal | null
  mobileSales: runtime.Decimal | null
  notes: string | null
  closedBy: string | null
  closedAt: Date | null
  createdAt: Date | null
}

export type DailyRegisterCountAggregateOutputType = {
  id: number
  date: number
  openingCash: number
  closingCash: number
  expectedCash: number
  discrepancy: number
  totalSales: number
  cashSales: number
  cardSales: number
  mobileSales: number
  notes: number
  closedBy: number
  closedAt: number
  createdAt: number
  _all: number
}


export type DailyRegisterAvgAggregateInputType = {
  openingCash?: true
  closingCash?: true
  expectedCash?: true
  discrepancy?: true
  totalSales?: true
  cashSales?: true
  cardSales?: true
  mobileSales?: true
}

export type DailyRegisterSumAggregateInputType = {
  openingCash?: true
  closingCash?: true
  expectedCash?: true
  discrepancy?: true
  totalSales?: true
  cashSales?: true
  cardSales?: true
  mobileSales?: true
}

export type DailyRegisterMinAggregateInputType = {
  id?: true
  date?: true
  openingCash?: true
  closingCash?: true
  expectedCash?: true
  discrepancy?: true
  totalSales?: true
  cashSales?: true
  cardSales?: true
  mobileSales?: true
  notes?: true
  closedBy?: true
  closedAt?: true
  createdAt?: true
}

export type DailyRegisterMaxAggregateInputType = {
  id?: true
  date?: true
  openingCash?: true
  closingCash?: true
  expectedCash?: true
  discrepancy?: true
  totalSales?: true
  cashSales?: true
  cardSales?: true
  mobileSales?: true
  notes?: true
  closedBy?: true
  closedAt?: true
  createdAt?: true
}

export type DailyRegisterCountAggregateInputType = {
  id?: true
  date?: true
  openingCash?: true
  closingCash?: true
  expectedCash?: true
  discrepancy?: true
  totalSales?: true
  cashSales?: true
  cardSales?: true
  mobileSales?: true
  notes?: true
  closedBy?: true
  closedAt?: true
  createdAt?: true
  _all?: true
}

export type DailyRegisterAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which DailyRegister to aggregate.
   */
  where?: Prisma.DailyRegisterWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of DailyRegisters to fetch.
   */
  orderBy?: Prisma.DailyRegisterOrderByWithRelationInput | Prisma.DailyRegisterOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.DailyRegisterWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` DailyRegisters from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` DailyRegisters.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned DailyRegisters
  **/
  _count?: true | DailyRegisterCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: DailyRegisterAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: DailyRegisterSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: DailyRegisterMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: DailyRegisterMaxAggregateInputType
}

export type GetDailyRegisterAggregateType<T extends DailyRegisterAggregateArgs> = {
      [P in keyof T & keyof AggregateDailyRegister]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateDailyRegister[P]>
    : Prisma.GetScalarType<T[P], AggregateDailyRegister[P]>
}




export type DailyRegisterGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.DailyRegisterWhereInput
  orderBy?: Prisma.DailyRegisterOrderByWithAggregationInput | Prisma.DailyRegisterOrderByWithAggregationInput[]
  by: Prisma.DailyRegisterScalarFieldEnum[] | Prisma.DailyRegisterScalarFieldEnum
  having?: Prisma.DailyRegisterScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: DailyRegisterCountAggregateInputType | true
  _avg?: DailyRegisterAvgAggregateInputType
  _sum?: DailyRegisterSumAggregateInputType
  _min?: DailyRegisterMinAggregateInputType
  _max?: DailyRegisterMaxAggregateInputType
}

export type DailyRegisterGroupByOutputType = {
  id: string
  date: Date
  openingCash: runtime.Decimal
  closingCash: runtime.Decimal
  expectedCash: runtime.Decimal
  discrepancy: runtime.Decimal
  totalSales: runtime.Decimal
  cashSales: runtime.Decimal
  cardSales: runtime.Decimal
  mobileSales: runtime.Decimal
  notes: string | null
  closedBy: string | null
  closedAt: Date | null
  createdAt: Date
  _count: DailyRegisterCountAggregateOutputType | null
  _avg: DailyRegisterAvgAggregateOutputType | null
  _sum: DailyRegisterSumAggregateOutputType | null
  _min: DailyRegisterMinAggregateOutputType | null
  _max: DailyRegisterMaxAggregateOutputType | null
}

type GetDailyRegisterGroupByPayload<T extends DailyRegisterGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<DailyRegisterGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof DailyRegisterGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], DailyRegisterGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], DailyRegisterGroupByOutputType[P]>
      }
    >
  >



export type DailyRegisterWhereInput = {
  AND?: Prisma.DailyRegisterWhereInput | Prisma.DailyRegisterWhereInput[]
  OR?: Prisma.DailyRegisterWhereInput[]
  NOT?: Prisma.DailyRegisterWhereInput | Prisma.DailyRegisterWhereInput[]
  id?: Prisma.StringFilter<"DailyRegister"> | string
  date?: Prisma.DateTimeFilter<"DailyRegister"> | Date | string
  openingCash?: Prisma.DecimalFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  closingCash?: Prisma.DecimalFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  expectedCash?: Prisma.DecimalFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  discrepancy?: Prisma.DecimalFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  totalSales?: Prisma.DecimalFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  cashSales?: Prisma.DecimalFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  cardSales?: Prisma.DecimalFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  mobileSales?: Prisma.DecimalFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  notes?: Prisma.StringNullableFilter<"DailyRegister"> | string | null
  closedBy?: Prisma.StringNullableFilter<"DailyRegister"> | string | null
  closedAt?: Prisma.DateTimeNullableFilter<"DailyRegister"> | Date | string | null
  createdAt?: Prisma.DateTimeFilter<"DailyRegister"> | Date | string
}

export type DailyRegisterOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  date?: Prisma.SortOrder
  openingCash?: Prisma.SortOrder
  closingCash?: Prisma.SortOrder
  expectedCash?: Prisma.SortOrder
  discrepancy?: Prisma.SortOrder
  totalSales?: Prisma.SortOrder
  cashSales?: Prisma.SortOrder
  cardSales?: Prisma.SortOrder
  mobileSales?: Prisma.SortOrder
  notes?: Prisma.SortOrderInput | Prisma.SortOrder
  closedBy?: Prisma.SortOrderInput | Prisma.SortOrder
  closedAt?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type DailyRegisterWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  date?: Date | string
  AND?: Prisma.DailyRegisterWhereInput | Prisma.DailyRegisterWhereInput[]
  OR?: Prisma.DailyRegisterWhereInput[]
  NOT?: Prisma.DailyRegisterWhereInput | Prisma.DailyRegisterWhereInput[]
  openingCash?: Prisma.DecimalFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  closingCash?: Prisma.DecimalFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  expectedCash?: Prisma.DecimalFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  discrepancy?: Prisma.DecimalFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  totalSales?: Prisma.DecimalFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  cashSales?: Prisma.DecimalFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  cardSales?: Prisma.DecimalFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  mobileSales?: Prisma.DecimalFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  notes?: Prisma.StringNullableFilter<"DailyRegister"> | string | null
  closedBy?: Prisma.StringNullableFilter<"DailyRegister"> | string | null
  closedAt?: Prisma.DateTimeNullableFilter<"DailyRegister"> | Date | string | null
  createdAt?: Prisma.DateTimeFilter<"DailyRegister"> | Date | string
}, "id" | "date">

export type DailyRegisterOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  date?: Prisma.SortOrder
  openingCash?: Prisma.SortOrder
  closingCash?: Prisma.SortOrder
  expectedCash?: Prisma.SortOrder
  discrepancy?: Prisma.SortOrder
  totalSales?: Prisma.SortOrder
  cashSales?: Prisma.SortOrder
  cardSales?: Prisma.SortOrder
  mobileSales?: Prisma.SortOrder
  notes?: Prisma.SortOrderInput | Prisma.SortOrder
  closedBy?: Prisma.SortOrderInput | Prisma.SortOrder
  closedAt?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  _count?: Prisma.DailyRegisterCountOrderByAggregateInput
  _avg?: Prisma.DailyRegisterAvgOrderByAggregateInput
  _max?: Prisma.DailyRegisterMaxOrderByAggregateInput
  _min?: Prisma.DailyRegisterMinOrderByAggregateInput
  _sum?: Prisma.DailyRegisterSumOrderByAggregateInput
}

export type DailyRegisterScalarWhereWithAggregatesInput = {
  AND?: Prisma.DailyRegisterScalarWhereWithAggregatesInput | Prisma.DailyRegisterScalarWhereWithAggregatesInput[]
  OR?: Prisma.DailyRegisterScalarWhereWithAggregatesInput[]
  NOT?: Prisma.DailyRegisterScalarWhereWithAggregatesInput | Prisma.DailyRegisterScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"DailyRegister"> | string
  date?: Prisma.DateTimeWithAggregatesFilter<"DailyRegister"> | Date | string
  openingCash?: Prisma.DecimalWithAggregatesFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  closingCash?: Prisma.DecimalWithAggregatesFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  expectedCash?: Prisma.DecimalWithAggregatesFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  discrepancy?: Prisma.DecimalWithAggregatesFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  totalSales?: Prisma.DecimalWithAggregatesFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  cashSales?: Prisma.DecimalWithAggregatesFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  cardSales?: Prisma.DecimalWithAggregatesFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  mobileSales?: Prisma.DecimalWithAggregatesFilter<"DailyRegister"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  notes?: Prisma.StringNullableWithAggregatesFilter<"DailyRegister"> | string | null
  closedBy?: Prisma.StringNullableWithAggregatesFilter<"DailyRegister"> | string | null
  closedAt?: Prisma.DateTimeNullableWithAggregatesFilter<"DailyRegister"> | Date | string | null
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"DailyRegister"> | Date | string
}

export type DailyRegisterCreateInput = {
  id?: string
  date: Date | string
  openingCash: runtime.Decimal | runtime.DecimalJsLike | number | string
  closingCash: runtime.Decimal | runtime.DecimalJsLike | number | string
  expectedCash: runtime.Decimal | runtime.DecimalJsLike | number | string
  discrepancy: runtime.Decimal | runtime.DecimalJsLike | number | string
  totalSales: runtime.Decimal | runtime.DecimalJsLike | number | string
  cashSales: runtime.Decimal | runtime.DecimalJsLike | number | string
  cardSales: runtime.Decimal | runtime.DecimalJsLike | number | string
  mobileSales: runtime.Decimal | runtime.DecimalJsLike | number | string
  notes?: string | null
  closedBy?: string | null
  closedAt?: Date | string | null
  createdAt?: Date | string
}

export type DailyRegisterUncheckedCreateInput = {
  id?: string
  date: Date | string
  openingCash: runtime.Decimal | runtime.DecimalJsLike | number | string
  closingCash: runtime.Decimal | runtime.DecimalJsLike | number | string
  expectedCash: runtime.Decimal | runtime.DecimalJsLike | number | string
  discrepancy: runtime.Decimal | runtime.DecimalJsLike | number | string
  totalSales: runtime.Decimal | runtime.DecimalJsLike | number | string
  cashSales: runtime.Decimal | runtime.DecimalJsLike | number | string
  cardSales: runtime.Decimal | runtime.DecimalJsLike | number | string
  mobileSales: runtime.Decimal | runtime.DecimalJsLike | number | string
  notes?: string | null
  closedBy?: string | null
  closedAt?: Date | string | null
  createdAt?: Date | string
}

export type DailyRegisterUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  openingCash?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  closingCash?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  expectedCash?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  discrepancy?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  totalSales?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  cashSales?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  cardSales?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  mobileSales?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  closedBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  closedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type DailyRegisterUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  openingCash?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  closingCash?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  expectedCash?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  discrepancy?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  totalSales?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  cashSales?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  cardSales?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  mobileSales?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  closedBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  closedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type DailyRegisterCreateManyInput = {
  id?: string
  date: Date | string
  openingCash: runtime.Decimal | runtime.DecimalJsLike | number | string
  closingCash: runtime.Decimal | runtime.DecimalJsLike | number | string
  expectedCash: runtime.Decimal | runtime.DecimalJsLike | number | string
  discrepancy: runtime.Decimal | runtime.DecimalJsLike | number | string
  totalSales: runtime.Decimal | runtime.DecimalJsLike | number | string
  cashSales: runtime.Decimal | runtime.DecimalJsLike | number | string
  cardSales: runtime.Decimal | runtime.DecimalJsLike | number | string
  mobileSales: runtime.Decimal | runtime.DecimalJsLike | number | string
  notes?: string | null
  closedBy?: string | null
  closedAt?: Date | string | null
  createdAt?: Date | string
}

export type DailyRegisterUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  openingCash?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  closingCash?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  expectedCash?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  discrepancy?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  totalSales?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  cashSales?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  cardSales?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  mobileSales?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  closedBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  closedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type DailyRegisterUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  date?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  openingCash?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  closingCash?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  expectedCash?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  discrepancy?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  totalSales?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  cashSales?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  cardSales?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  mobileSales?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  closedBy?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  closedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type DailyRegisterCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  date?: Prisma.SortOrder
  openingCash?: Prisma.SortOrder
  closingCash?: Prisma.SortOrder
  expectedCash?: Prisma.SortOrder
  discrepancy?: Prisma.SortOrder
  totalSales?: Prisma.SortOrder
  cashSales?: Prisma.SortOrder
  cardSales?: Prisma.SortOrder
  mobileSales?: Prisma.SortOrder
  notes?: Prisma.SortOrder
  closedBy?: Prisma.SortOrder
  closedAt?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type DailyRegisterAvgOrderByAggregateInput = {
  openingCash?: Prisma.SortOrder
  closingCash?: Prisma.SortOrder
  expectedCash?: Prisma.SortOrder
  discrepancy?: Prisma.SortOrder
  totalSales?: Prisma.SortOrder
  cashSales?: Prisma.SortOrder
  cardSales?: Prisma.SortOrder
  mobileSales?: Prisma.SortOrder
}

export type DailyRegisterMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  date?: Prisma.SortOrder
  openingCash?: Prisma.SortOrder
  closingCash?: Prisma.SortOrder
  expectedCash?: Prisma.SortOrder
  discrepancy?: Prisma.SortOrder
  totalSales?: Prisma.SortOrder
  cashSales?: Prisma.SortOrder
  cardSales?: Prisma.SortOrder
  mobileSales?: Prisma.SortOrder
  notes?: Prisma.SortOrder
  closedBy?: Prisma.SortOrder
  closedAt?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type DailyRegisterMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  date?: Prisma.SortOrder
  openingCash?: Prisma.SortOrder
  closingCash?: Prisma.SortOrder
  expectedCash?: Prisma.SortOrder
  discrepancy?: Prisma.SortOrder
  totalSales?: Prisma.SortOrder
  cashSales?: Prisma.SortOrder
  cardSales?: Prisma.SortOrder
  mobileSales?: Prisma.SortOrder
  notes?: Prisma.SortOrder
  closedBy?: Prisma.SortOrder
  closedAt?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type DailyRegisterSumOrderByAggregateInput = {
  openingCash?: Prisma.SortOrder
  closingCash?: Prisma.SortOrder
  expectedCash?: Prisma.SortOrder
  discrepancy?: Prisma.SortOrder
  totalSales?: Prisma.SortOrder
  cashSales?: Prisma.SortOrder
  cardSales?: Prisma.SortOrder
  mobileSales?: Prisma.SortOrder
}



export type DailyRegisterSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  date?: boolean
  openingCash?: boolean
  closingCash?: boolean
  expectedCash?: boolean
  discrepancy?: boolean
  totalSales?: boolean
  cashSales?: boolean
  cardSales?: boolean
  mobileSales?: boolean
  notes?: boolean
  closedBy?: boolean
  closedAt?: boolean
  createdAt?: boolean
}, ExtArgs["result"]["dailyRegister"]>

export type DailyRegisterSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  date?: boolean
  openingCash?: boolean
  closingCash?: boolean
  expectedCash?: boolean
  discrepancy?: boolean
  totalSales?: boolean
  cashSales?: boolean
  cardSales?: boolean
  mobileSales?: boolean
  notes?: boolean
  closedBy?: boolean
  closedAt?: boolean
  createdAt?: boolean
}, ExtArgs["result"]["dailyRegister"]>

export type DailyRegisterSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  date?: boolean
  openingCash?: boolean
  closingCash?: boolean
  expectedCash?: boolean
  discrepancy?: boolean
  totalSales?: boolean
  cashSales?: boolean
  cardSales?: boolean
  mobileSales?: boolean
  notes?: boolean
  closedBy?: boolean
  closedAt?: boolean
  createdAt?: boolean
}, ExtArgs["result"]["dailyRegister"]>

export type DailyRegisterSelectScalar = {
  id?: boolean
  date?: boolean
  openingCash?: boolean
  closingCash?: boolean
  expectedCash?: boolean
  discrepancy?: boolean
  totalSales?: boolean
  cashSales?: boolean
  cardSales?: boolean
  mobileSales?: boolean
  notes?: boolean
  closedBy?: boolean
  closedAt?: boolean
  createdAt?: boolean
}

export type DailyRegisterOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "date" | "openingCash" | "closingCash" | "expectedCash" | "discrepancy" | "totalSales" | "cashSales" | "cardSales" | "mobileSales" | "notes" | "closedBy" | "closedAt" | "createdAt", ExtArgs["result"]["dailyRegister"]>

export type $DailyRegisterPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "DailyRegister"
  objects: {}
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    date: Date
    openingCash: runtime.Decimal
    closingCash: runtime.Decimal
    expectedCash: runtime.Decimal
    discrepancy: runtime.Decimal
    totalSales: runtime.Decimal
    cashSales: runtime.Decimal
    cardSales: runtime.Decimal
    mobileSales: runtime.Decimal
    notes: string | null
    closedBy: string | null
    closedAt: Date | null
    createdAt: Date
  }, ExtArgs["result"]["dailyRegister"]>
  composites: {}
}

export type DailyRegisterGetPayload<S extends boolean | null | undefined | DailyRegisterDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$DailyRegisterPayload, S>

export type DailyRegisterCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<DailyRegisterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: DailyRegisterCountAggregateInputType | true
  }

export interface DailyRegisterDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyRegister'], meta: { name: 'DailyRegister' } }
  /**
   * Find zero or one DailyRegister that matches the filter.
   * @param {DailyRegisterFindUniqueArgs} args - Arguments to find a DailyRegister
   * @example
   * // Get one DailyRegister
   * const dailyRegister = await prisma.dailyRegister.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends DailyRegisterFindUniqueArgs>(args: Prisma.SelectSubset<T, DailyRegisterFindUniqueArgs<ExtArgs>>): Prisma.Prisma__DailyRegisterClient<runtime.Types.Result.GetResult<Prisma.$DailyRegisterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one DailyRegister that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {DailyRegisterFindUniqueOrThrowArgs} args - Arguments to find a DailyRegister
   * @example
   * // Get one DailyRegister
   * const dailyRegister = await prisma.dailyRegister.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends DailyRegisterFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, DailyRegisterFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__DailyRegisterClient<runtime.Types.Result.GetResult<Prisma.$DailyRegisterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first DailyRegister that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DailyRegisterFindFirstArgs} args - Arguments to find a DailyRegister
   * @example
   * // Get one DailyRegister
   * const dailyRegister = await prisma.dailyRegister.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends DailyRegisterFindFirstArgs>(args?: Prisma.SelectSubset<T, DailyRegisterFindFirstArgs<ExtArgs>>): Prisma.Prisma__DailyRegisterClient<runtime.Types.Result.GetResult<Prisma.$DailyRegisterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first DailyRegister that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DailyRegisterFindFirstOrThrowArgs} args - Arguments to find a DailyRegister
   * @example
   * // Get one DailyRegister
   * const dailyRegister = await prisma.dailyRegister.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends DailyRegisterFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, DailyRegisterFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__DailyRegisterClient<runtime.Types.Result.GetResult<Prisma.$DailyRegisterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more DailyRegisters that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DailyRegisterFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all DailyRegisters
   * const dailyRegisters = await prisma.dailyRegister.findMany()
   * 
   * // Get first 10 DailyRegisters
   * const dailyRegisters = await prisma.dailyRegister.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const dailyRegisterWithIdOnly = await prisma.dailyRegister.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends DailyRegisterFindManyArgs>(args?: Prisma.SelectSubset<T, DailyRegisterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$DailyRegisterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a DailyRegister.
   * @param {DailyRegisterCreateArgs} args - Arguments to create a DailyRegister.
   * @example
   * // Create one DailyRegister
   * const DailyRegister = await prisma.dailyRegister.create({
   *   data: {
   *     // ... data to create a DailyRegister
   *   }
   * })
   * 
   */
  create<T extends DailyRegisterCreateArgs>(args: Prisma.SelectSubset<T, DailyRegisterCreateArgs<ExtArgs>>): Prisma.Prisma__DailyRegisterClient<runtime.Types.Result.GetResult<Prisma.$DailyRegisterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many DailyRegisters.
   * @param {DailyRegisterCreateManyArgs} args - Arguments to create many DailyRegisters.
   * @example
   * // Create many DailyRegisters
   * const dailyRegister = await prisma.dailyRegister.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends DailyRegisterCreateManyArgs>(args?: Prisma.SelectSubset<T, DailyRegisterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many DailyRegisters and returns the data saved in the database.
   * @param {DailyRegisterCreateManyAndReturnArgs} args - Arguments to create many DailyRegisters.
   * @example
   * // Create many DailyRegisters
   * const dailyRegister = await prisma.dailyRegister.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many DailyRegisters and only return the `id`
   * const dailyRegisterWithIdOnly = await prisma.dailyRegister.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends DailyRegisterCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, DailyRegisterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$DailyRegisterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a DailyRegister.
   * @param {DailyRegisterDeleteArgs} args - Arguments to delete one DailyRegister.
   * @example
   * // Delete one DailyRegister
   * const DailyRegister = await prisma.dailyRegister.delete({
   *   where: {
   *     // ... filter to delete one DailyRegister
   *   }
   * })
   * 
   */
  delete<T extends DailyRegisterDeleteArgs>(args: Prisma.SelectSubset<T, DailyRegisterDeleteArgs<ExtArgs>>): Prisma.Prisma__DailyRegisterClient<runtime.Types.Result.GetResult<Prisma.$DailyRegisterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one DailyRegister.
   * @param {DailyRegisterUpdateArgs} args - Arguments to update one DailyRegister.
   * @example
   * // Update one DailyRegister
   * const dailyRegister = await prisma.dailyRegister.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends DailyRegisterUpdateArgs>(args: Prisma.SelectSubset<T, DailyRegisterUpdateArgs<ExtArgs>>): Prisma.Prisma__DailyRegisterClient<runtime.Types.Result.GetResult<Prisma.$DailyRegisterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more DailyRegisters.
   * @param {DailyRegisterDeleteManyArgs} args - Arguments to filter DailyRegisters to delete.
   * @example
   * // Delete a few DailyRegisters
   * const { count } = await prisma.dailyRegister.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends DailyRegisterDeleteManyArgs>(args?: Prisma.SelectSubset<T, DailyRegisterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more DailyRegisters.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DailyRegisterUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many DailyRegisters
   * const dailyRegister = await prisma.dailyRegister.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends DailyRegisterUpdateManyArgs>(args: Prisma.SelectSubset<T, DailyRegisterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more DailyRegisters and returns the data updated in the database.
   * @param {DailyRegisterUpdateManyAndReturnArgs} args - Arguments to update many DailyRegisters.
   * @example
   * // Update many DailyRegisters
   * const dailyRegister = await prisma.dailyRegister.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more DailyRegisters and only return the `id`
   * const dailyRegisterWithIdOnly = await prisma.dailyRegister.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends DailyRegisterUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, DailyRegisterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$DailyRegisterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one DailyRegister.
   * @param {DailyRegisterUpsertArgs} args - Arguments to update or create a DailyRegister.
   * @example
   * // Update or create a DailyRegister
   * const dailyRegister = await prisma.dailyRegister.upsert({
   *   create: {
   *     // ... data to create a DailyRegister
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the DailyRegister we want to update
   *   }
   * })
   */
  upsert<T extends DailyRegisterUpsertArgs>(args: Prisma.SelectSubset<T, DailyRegisterUpsertArgs<ExtArgs>>): Prisma.Prisma__DailyRegisterClient<runtime.Types.Result.GetResult<Prisma.$DailyRegisterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of DailyRegisters.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DailyRegisterCountArgs} args - Arguments to filter DailyRegisters to count.
   * @example
   * // Count the number of DailyRegisters
   * const count = await prisma.dailyRegister.count({
   *   where: {
   *     // ... the filter for the DailyRegisters we want to count
   *   }
   * })
  **/
  count<T extends DailyRegisterCountArgs>(
    args?: Prisma.Subset<T, DailyRegisterCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], DailyRegisterCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a DailyRegister.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DailyRegisterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends DailyRegisterAggregateArgs>(args: Prisma.Subset<T, DailyRegisterAggregateArgs>): Prisma.PrismaPromise<GetDailyRegisterAggregateType<T>>

  /**
   * Group by DailyRegister.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {DailyRegisterGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends DailyRegisterGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: DailyRegisterGroupByArgs['orderBy'] }
      : { orderBy?: DailyRegisterGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, DailyRegisterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyRegisterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the DailyRegister model
 */
readonly fields: DailyRegisterFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for DailyRegister.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__DailyRegisterClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the DailyRegister model
 */
export interface DailyRegisterFieldRefs {
  readonly id: Prisma.FieldRef<"DailyRegister", 'String'>
  readonly date: Prisma.FieldRef<"DailyRegister", 'DateTime'>
  readonly openingCash: Prisma.FieldRef<"DailyRegister", 'Decimal'>
  readonly closingCash: Prisma.FieldRef<"DailyRegister", 'Decimal'>
  readonly expectedCash: Prisma.FieldRef<"DailyRegister", 'Decimal'>
  readonly discrepancy: Prisma.FieldRef<"DailyRegister", 'Decimal'>
  readonly totalSales: Prisma.FieldRef<"DailyRegister", 'Decimal'>
  readonly cashSales: Prisma.FieldRef<"DailyRegister", 'Decimal'>
  readonly cardSales: Prisma.FieldRef<"DailyRegister", 'Decimal'>
  readonly mobileSales: Prisma.FieldRef<"DailyRegister", 'Decimal'>
  readonly notes: Prisma.FieldRef<"DailyRegister", 'String'>
  readonly closedBy: Prisma.FieldRef<"DailyRegister", 'String'>
  readonly closedAt: Prisma.FieldRef<"DailyRegister", 'DateTime'>
  readonly createdAt: Prisma.FieldRef<"DailyRegister", 'DateTime'>
}
    

// Custom InputTypes
/**
 * DailyRegister findUnique
 */
export type DailyRegisterFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailyRegister
   */
  select?: Prisma.DailyRegisterSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DailyRegister
   */
  omit?: Prisma.DailyRegisterOmit<ExtArgs> | null
  /**
   * Filter, which DailyRegister to fetch.
   */
  where: Prisma.DailyRegisterWhereUniqueInput
}

/**
 * DailyRegister findUniqueOrThrow
 */
export type DailyRegisterFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailyRegister
   */
  select?: Prisma.DailyRegisterSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DailyRegister
   */
  omit?: Prisma.DailyRegisterOmit<ExtArgs> | null
  /**
   * Filter, which DailyRegister to fetch.
   */
  where: Prisma.DailyRegisterWhereUniqueInput
}

/**
 * DailyRegister findFirst
 */
export type DailyRegisterFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailyRegister
   */
  select?: Prisma.DailyRegisterSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DailyRegister
   */
  omit?: Prisma.DailyRegisterOmit<ExtArgs> | null
  /**
   * Filter, which DailyRegister to fetch.
   */
  where?: Prisma.DailyRegisterWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of DailyRegisters to fetch.
   */
  orderBy?: Prisma.DailyRegisterOrderByWithRelationInput | Prisma.DailyRegisterOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for DailyRegisters.
   */
  cursor?: Prisma.DailyRegisterWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` DailyRegisters from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` DailyRegisters.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of DailyRegisters.
   */
  distinct?: Prisma.DailyRegisterScalarFieldEnum | Prisma.DailyRegisterScalarFieldEnum[]
}

/**
 * DailyRegister findFirstOrThrow
 */
export type DailyRegisterFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailyRegister
   */
  select?: Prisma.DailyRegisterSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DailyRegister
   */
  omit?: Prisma.DailyRegisterOmit<ExtArgs> | null
  /**
   * Filter, which DailyRegister to fetch.
   */
  where?: Prisma.DailyRegisterWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of DailyRegisters to fetch.
   */
  orderBy?: Prisma.DailyRegisterOrderByWithRelationInput | Prisma.DailyRegisterOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for DailyRegisters.
   */
  cursor?: Prisma.DailyRegisterWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` DailyRegisters from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` DailyRegisters.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of DailyRegisters.
   */
  distinct?: Prisma.DailyRegisterScalarFieldEnum | Prisma.DailyRegisterScalarFieldEnum[]
}

/**
 * DailyRegister findMany
 */
export type DailyRegisterFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailyRegister
   */
  select?: Prisma.DailyRegisterSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DailyRegister
   */
  omit?: Prisma.DailyRegisterOmit<ExtArgs> | null
  /**
   * Filter, which DailyRegisters to fetch.
   */
  where?: Prisma.DailyRegisterWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of DailyRegisters to fetch.
   */
  orderBy?: Prisma.DailyRegisterOrderByWithRelationInput | Prisma.DailyRegisterOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing DailyRegisters.
   */
  cursor?: Prisma.DailyRegisterWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` DailyRegisters from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` DailyRegisters.
   */
  skip?: number
  distinct?: Prisma.DailyRegisterScalarFieldEnum | Prisma.DailyRegisterScalarFieldEnum[]
}

/**
 * DailyRegister create
 */
export type DailyRegisterCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailyRegister
   */
  select?: Prisma.DailyRegisterSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DailyRegister
   */
  omit?: Prisma.DailyRegisterOmit<ExtArgs> | null
  /**
   * The data needed to create a DailyRegister.
   */
  data: Prisma.XOR<Prisma.DailyRegisterCreateInput, Prisma.DailyRegisterUncheckedCreateInput>
}

/**
 * DailyRegister createMany
 */
export type DailyRegisterCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many DailyRegisters.
   */
  data: Prisma.DailyRegisterCreateManyInput | Prisma.DailyRegisterCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * DailyRegister createManyAndReturn
 */
export type DailyRegisterCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailyRegister
   */
  select?: Prisma.DailyRegisterSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the DailyRegister
   */
  omit?: Prisma.DailyRegisterOmit<ExtArgs> | null
  /**
   * The data used to create many DailyRegisters.
   */
  data: Prisma.DailyRegisterCreateManyInput | Prisma.DailyRegisterCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * DailyRegister update
 */
export type DailyRegisterUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailyRegister
   */
  select?: Prisma.DailyRegisterSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DailyRegister
   */
  omit?: Prisma.DailyRegisterOmit<ExtArgs> | null
  /**
   * The data needed to update a DailyRegister.
   */
  data: Prisma.XOR<Prisma.DailyRegisterUpdateInput, Prisma.DailyRegisterUncheckedUpdateInput>
  /**
   * Choose, which DailyRegister to update.
   */
  where: Prisma.DailyRegisterWhereUniqueInput
}

/**
 * DailyRegister updateMany
 */
export type DailyRegisterUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update DailyRegisters.
   */
  data: Prisma.XOR<Prisma.DailyRegisterUpdateManyMutationInput, Prisma.DailyRegisterUncheckedUpdateManyInput>
  /**
   * Filter which DailyRegisters to update
   */
  where?: Prisma.DailyRegisterWhereInput
  /**
   * Limit how many DailyRegisters to update.
   */
  limit?: number
}

/**
 * DailyRegister updateManyAndReturn
 */
export type DailyRegisterUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailyRegister
   */
  select?: Prisma.DailyRegisterSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the DailyRegister
   */
  omit?: Prisma.DailyRegisterOmit<ExtArgs> | null
  /**
   * The data used to update DailyRegisters.
   */
  data: Prisma.XOR<Prisma.DailyRegisterUpdateManyMutationInput, Prisma.DailyRegisterUncheckedUpdateManyInput>
  /**
   * Filter which DailyRegisters to update
   */
  where?: Prisma.DailyRegisterWhereInput
  /**
   * Limit how many DailyRegisters to update.
   */
  limit?: number
}

/**
 * DailyRegister upsert
 */
export type DailyRegisterUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailyRegister
   */
  select?: Prisma.DailyRegisterSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DailyRegister
   */
  omit?: Prisma.DailyRegisterOmit<ExtArgs> | null
  /**
   * The filter to search for the DailyRegister to update in case it exists.
   */
  where: Prisma.DailyRegisterWhereUniqueInput
  /**
   * In case the DailyRegister found by the `where` argument doesn't exist, create a new DailyRegister with this data.
   */
  create: Prisma.XOR<Prisma.DailyRegisterCreateInput, Prisma.DailyRegisterUncheckedCreateInput>
  /**
   * In case the DailyRegister was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.DailyRegisterUpdateInput, Prisma.DailyRegisterUncheckedUpdateInput>
}

/**
 * DailyRegister delete
 */
export type DailyRegisterDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailyRegister
   */
  select?: Prisma.DailyRegisterSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DailyRegister
   */
  omit?: Prisma.DailyRegisterOmit<ExtArgs> | null
  /**
   * Filter which DailyRegister to delete.
   */
  where: Prisma.DailyRegisterWhereUniqueInput
}

/**
 * DailyRegister deleteMany
 */
export type DailyRegisterDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which DailyRegisters to delete
   */
  where?: Prisma.DailyRegisterWhereInput
  /**
   * Limit how many DailyRegisters to delete.
   */
  limit?: number
}

/**
 * DailyRegister without action
 */
export type DailyRegisterDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DailyRegister
   */
  select?: Prisma.DailyRegisterSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DailyRegister
   */
  omit?: Prisma.DailyRegisterOmit<ExtArgs> | null
}
